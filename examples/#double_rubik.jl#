using LARVIEW

V,cells = LARLIB.larCuboids([3,3,3],true)
FV = cells[3]
V = convert(Array{Float64,2}, V)
LARVIEW.viewexploded(V,FV);

# translate the columns of `V` matrix by sum with `t` vector
function translate( t, V )
	broadcast(+,t,V)
end

# scale the columns of `V` matrix by product times `s` vector
function scale( s, V )
	broadcast(*,s,V)
end

# rotate the columns of `V` matrix by properly using the `args` parameters
function rotate(args,V)
	n = length(args)
	if n == 1 # rotation in 2D
		angle = args[1]; Cos = cos(angle); Sin = sin(angle)
		mat = eye(2)
		mat[1,1] = Cos;    mat[1,2] = -Sin;
		mat[2,1] = Sin;    mat[2,2] = Cos;
	elseif n == 3 # rotation in 3D
		mat = eye(3)
		angle = norm(collect(args)); axis = normalize(collect(args))
		Cos = cos(angle); Sin = sin(angle)
		# elementary rotations (in 3D)
		if axis[2]==axis[3]==0.0    # rotation about x
			mat[2,2] = Cos;    mat[2,3] = -Sin;
			mat[3,2] = Sin;    mat[3,3] = Cos;
		elseif axis[1]==axis[3]==0.0    # rotation about y
			mat[1,1] = Cos;    mat[1,3] = Sin;
			mat[3,1] = -Sin;    mat[3,3] = Cos;
		elseif axis[1]==axis[2]==0.0    # rotation about z
			mat[1,1] = Cos;    mat[1,2] = -Sin;
			mat[2,1] = Sin;    mat[2,2] = Cos;
		# general rotations (in 3D)
		else  # general 3D rotation (Rodrigues' rotation formula)    
			I = eye(3) ; u = axis;
			Ux = Array([
				 0        -u[3]      u[2];
				 u[3]        0      -u[1];
				-u[2]      u[1]        0 ])
			UU = Array([
				 u[1]*u[1]    u[1]*u[2]    u[1]*u[3];
				 u[2]*u[1]    u[2]*u[2]    u[2]*u[3];
				 u[3]*u[1]    u[3]*u[2]    u[3]*u[3] ])
			mat = Cos*I + Sin*Ux + (1.0-Cos)*UU
		end
	end
	mat*V
end

V = translate([-1.5,-1.5,-1.5],V)
LARVIEW.viewexploded(V,FV);
V = scale([.25,.25,.25],V)
LARVIEW.viewexploded(V,FV);

W = copy(V)
FW = copy(FV)

W = rotate((0,π/3,0),rotate((π/3,0,0), W))
LARVIEW.viewexploded(W,FW);

